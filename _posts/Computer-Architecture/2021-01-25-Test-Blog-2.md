---	
layout:     post	
title:      『Computer Architecture』 Pipeline CPU	
subtitle:   『计算机体系结构』 流水线CPU    
date:       2021-01-25	   
author:     Coekjan 
header-img: img/post-bg-CA.jpg	
catalog:    true    
katex:  true    
tags:	
    - Computer Architecture  
---

本节将构造一个支持[指令集](https://blog.coekjan.cn/2021/01/13/Introduction/#指令集仅支持定点指令)中前50条指令的流水线CPU. 暂不进行异常检测.

## 流水线思想

### 单周期缺陷

单周期CPU使用一周期完成一条指令, 包括 **取指令(F)->译码(D)->执行(E)->访存(M)->写回(W)** 五个步骤, 这意味着无论CPU当前运行的指令是否完全需要这五个步骤, 都要经历一整个周期的时间才能取出下一指令.

例如: `addu`指令并不需要访存(M), `j`指令并不需要执行(E)...

这将导致单周期CPU的重大缺陷: CPU时钟周期必须与指令集中**执行时间最长**的指令相匹配. 这条执行时间最长的指令即为**关键路径**.

> 例如, `lw` 需要完全经历上述五个步骤才能完成, 因此CPU的时钟周期必须要比 `lw` 的执行时间要长.

![]({{ '/img/SCPU-Disadvan.svg' | prepend: site.baseurl}})

### 五级流水线

> 流水线是一种实现指令级并行的技术手段.

工厂生产零件应用了流水线的思想: 将工人分为三个组别A, B, C. A组对零件进行初加工, B组接受A组加工结果进行进一步加工, C组接受B组加工结果进行最终加工. 这样安排的好处显而易见: 允许有三个零件同时在生产线中生产, 每一个组别的工人都完全投入工作, 没有工人空闲.

同样的原理可应用于CPU技术中. 我们在上面的讨论中得知, 指令执行包含 **取指令(F)->译码(D)->执行(E)->访存(M)->写回(W)** 五个阶段.

> 以下的流水线均指五级流水线.

下图比较了同一指令序列在单周期与流水线上的运行效果.

![]({{ '/img/P-CPU-Time.svg' | prepend: site.baseurl}})

可以看见流水线的本质是指令的并行执行. 为实现流水线, 我们须在单周期CPU的通路中增加流水线寄存器, 用以保存上一阶段的结果, 并为当前阶段提供数据. 下图是在上一节中单周期通路插入了流水线寄存器.

![]({{ '../../img/P-CPU-DP-1.svg' | prepend: site.baseurl}})

> 译码 (D) 级虽称为"译码", 但实际上进行了寄存器的读取, 立即数的扩展等.

本系列博文约定:
* F与D级之间的流水线寄存器称为**D级寄存器**
* D与E级之间的流水线寄存器称为**E级寄存器**
* E与M级之间的流水线寄存器称为**M级寄存器**
* M与W级之间的流水线寄存器称为**W级寄存器**

## 流水线冒险 - Hazard

### 结构冒险, 数据冒险与控制冒险

**结构冒险**: 因缺乏硬件支持而导致指令不能在预定的时钟周期内执行. 若IM与DM使用同一个存储器实现, 则会导致不能同时取指令与取数据, 发生结构冒险. 我们的设计中不存在结构冒险.

**数据冒险**: 因指令间存在相关性, 无法提供指令执行所需的数据而导致指令不能在预定的时钟周期内执行. 如:

```mips
addu    $1, $2, $3
subu    $2, $1, $3
```

在不做任何干预的情况下, 当`addu`仍处于流水线中时, `subu`无法从GRF中获取正确的`$1`的值. 我们采用转发与阻塞的方法解决这种冒险.

**控制冒险**: 由于分支, 取得的指令并不是所需运行的指令而导致指令不能在预定的时钟周期内执行. 我们的设计中使用延迟槽解决这种冒险.

### 转发与阻塞

**需求-供给模型**: 当某一端口需要使用数据时, 我们称之为**需求端**, 为之提供数据的端口称为**供给端**. 我们只需要二把某一需求端对应的所有供给端找到, 并置一多路选择器进行选择供给的数据, 通过控制器得到合适的选择信号, 需求端即可得到正确的数据.

> 需要注意的是我们的设计中供给端必须是**寄存器**的输出端, 否则将有可能使得关键路径延长, 时钟频率受到限制.

以ALU的SrcA端口为例, SrcA是一需求端, 其供给端有可能是E级流水寄存器, M级寄存器, W级寄存器. 显然**M级寄存器存有的数据是最新的, W级寄存器存有的数据是次新的, E级寄存器存有的数据是最旧的.** 举例如下:

考虑指令序列:

```mips
addu    $1, $2, $3
addu    $1, $1, $3
subu    $2, $1, $2
addu    $2, $1, $1
```

![]({{ '/img/P-CPU-ALUSrcA-forwrarding.svg' | prepend: site.baseurl}})

但有些情况下仅靠转发不能完全解决数据冲突, 如:

```mips
lw      $1, 0($0)
addu    $2, $1, $3
```

当`addu`到达E级, ALU的SrcA端是需求端, 但是`lw`还处于M级, 未取出`$1`的数据. 此时只能暂停流水线一周期, 即PC和D级流水线寄存器的使能端置`0`, E级流水线寄存器插入"气泡"`nop`. 一周期后, `lw`产生的数据就可以通过转发传递给`addu`了.

> 后文 **AT 方法**将详细说明转发与阻塞的判定与信号的产生.

![]({{ '/img/P-CPU-ALUSrcA-stall.svg' | prepend: site.baseurl}})

### 跳转延迟槽

本设计中, 我们在D级加入一个比较模块CMP, 用于分支指令的条件判断, 并允许延迟槽: 若`PC`指向分支指令, 那么执行完分支指令后, 将继续执行`PC+4`对应的指令(称这个指令位于**延迟槽**内), 随后再执行分支后的指令. 这样的设计可以有效解决控制冒险 - 分支指令有足够的时间用于判断转移与否.

> 编译器将调度合适的指令插入延迟槽.

## 流水线数据通路

// 待续...

### 构建无旁路的通路 - 功能实现

### 增加转发旁路 - 冲突解决

## 流水线控制

在流水线控制中, 有两种主要的译码方法:
1. 集中式译码: 
2. 分布式译码: 

### 功能性信号产生

### 转发与阻塞信号产生 - AT方法

## 流水线系统测试

### 正确性测试

### 冲突性测试

## 流水线增量开发